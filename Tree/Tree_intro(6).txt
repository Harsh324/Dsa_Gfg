## Construct Binary tree from Inorder and Preorder

    ** We are Given Inorder and Preorder traversals of Binary tree,
       we need to construct the Binary tree.
    
    ** We can Construct Binary tree only by Inorder traversal,
       along with one more traversal is given.

    ** Inorder : Left, Root, Right
    ** Preorder : Root, Left, Right


    ## Approach 1 :

         struct Node  
        { 
            int key; 
            struct Node *left; 
            struct Node *right; 
            Node(int k){
                key=k;
                left=right=NULL;
            }
        };

        void inorder(Node *root){
            if(root!=NULL){
                inorder(root->left);
                cout<<root->key<<" ";
                inorder(root->right);    
            }
        }  

        int preIndex=0;
        Node *cTree(int in[],int pre[],int is,int ie){
            if(is>ie)return NULL;
            Node *root=new Node(pre[preIndex++]);
            
            int inIndex;
            for(int i=is;i<=ie;i++){
                if(in[i]==root->key){
                    inIndex=i;
                    break;
                }
            }
            root->left=cTree(in, pre, is, inIndex-1);
            root->right=cTree(in, pre, inIndex+1, ie);
            return root;
        }

        int main() {
            
            int in[]={20,10,40,30,50};
            int pre[]={10,20,30,40,50};
            int n=sizeof(in)/sizeof(in[0]);
            Node *root=cTree(in, pre, 0, n-1);
            inorder(root);
        }

        Time Complexity : O(N^2)



## Tree Traversal in Spiral Form  

    ** We are Given a Binary Tree we need to do level order traversal,
       of the tree in spiral form.

    
    ## Approach : 

        ** Using Queue and Stack based on level order traversal.

        struct Node  
        { 
            int key; 
            struct Node *left; 
            struct Node *right; 
            Node(int k){
                key=k;
                left=right=NULL;
            }
        };

        void printSpiral(Node *root){
            if(root==NULL)return;
            queue<Node *>q;
            stack<int> s;
            bool reverse=false;
            q.push(root);
            while(q.empty()==false){
                int count=q.size();
                for(int i=0;i<count;i++){
                Node *curr=q.front();
                q.pop();
                if(reverse)
                    s.push(curr->key);
                else
                    cout<<curr->key<<" ";
                if(curr->left!=NULL)
                    q.push(curr->left);
                if(curr->right!=NULL)
                    q.push(curr->right);
                }
                if(reverse){
                    while(s.empty()==false){
                        cout<<s.top()<<" ";
                        s.pop();
                    }
                }
            reverse=!reverse;
            }
        }  

        int main() {
            
            Node *root=new Node(1);
            root->left=new Node(2);
            root->right=new Node(3);
            root->left->left=new Node(4);
            root->left->right=new Node(5);
            root->right->left=new Node(6);
            root->right->right=new Node(7);
            
            printSpiral(root);
        }

        Time Complexity : O(N)


    ## Approach 2 : 

        ** Idea is to usee two stacks

        ** While any of the two stacks is not empty

            ** While S1 is Not Empty

                ** Take out a Node, Print it
                ** Push Children of the taken out node int S2.

            ** While S2 is bot empty

                ** Take out a Node, print it.
                ** Push childre of the Taken out Node int S1 in Reverse oreder.
